1733139567
a:2:{s:7:"content";s:8413:"<p>大家好，这篇文章，我们来分享一下，如何给Orangepi 3 LTS安装Gentoo</p>
<h2>硬件配置</h2>
<h3>产品参数</h3>
<table>
<thead>
<tr>
<th>CPU</th>
<th>全志 H6  &lt;br&gt;四核 64 位 1.8GHz 高性能 Cortex-A53 处理器</th>
</tr>
</thead>
<tbody>
<tr>
<td>GPU</td>
<td>• High-performance multi-core GPU Mali T720&lt;br&gt;&lt;br&gt;• OpenGL ES3.1/3.0/2.0/1.1&lt;br&gt;&lt;br&gt;• Microsoft DirectX 11 FL9_3&lt;br&gt;&lt;br&gt;• ASTC(Adaptive Scalable Texture Compression)&lt;br&gt;&lt;br&gt;• Floating point operation greater than 70 GFLOPS</td>
</tr>
<tr>
<td>电源管理芯片</td>
<td>AXP805</td>
</tr>
<tr>
<td>内存</td>
<td>2GB LPDDR3 (与 GPU 共享)</td>
</tr>
<tr>
<td>板载存储</td>
<td>• TF卡插槽 &lt;br&gt;&lt;br&gt; • 8GB EMMC Flash</td>
</tr>
<tr>
<td>板载以太网</td>
<td>• YT8531C芯片&lt;br&gt;&lt;br&gt; • 支持10/100M/1000M 以太网</td>
</tr>
<tr>
<td>板载WIFI+蓝牙</td>
<td>• AW859A芯片 &lt;br&gt;&lt;br&gt; • 支持IEEE 802.11 a/b/g/n/ac &lt;br&gt;&lt;br&gt; • 支持BT5.0</td>
</tr>
<tr>
<td>视频输出</td>
<td>• HDMI 2.0a &lt;br&gt;&lt;br&gt; • TV CVBS Output</td>
</tr>
<tr>
<td>音频输出</td>
<td>• HDMI输出&lt;br&gt;&lt;br&gt; • 3.5mm音频口</td>
</tr>
<tr>
<td>电源</td>
<td>5V3A Type-C供电</td>
</tr>
<tr>
<td>USB 端口</td>
<td>1 <em> USB 3.0 HOST、2 </em> USB 2.0 HOST</td>
</tr>
<tr>
<td>Low-level 外设</td>
<td>26pin 接头带有1<em>I2C、1</em>SPI、1*UART及多个GPIO口</td>
</tr>
<tr>
<td>调试串口</td>
<td>UART-TX、UART-RX以及GND</td>
</tr>
<tr>
<td>按键</td>
<td>电源按键(SW4)</td>
</tr>
<tr>
<td>LED灯</td>
<td>电源指示灯和状态指示灯</td>
</tr>
<tr>
<td>红外接收</td>
<td>支持红外遥控器</td>
</tr>
<tr>
<td>支持的操作系统</td>
<td>Android 9.0、Ubuntu、Debian等操作系统</td>
</tr>
</tbody>
</table>
<h2>构建可引导镜像</h2>
<ol>
<li>
<p>单击<a href="http://www.orangepi.cn/html/hardWare/computerAndMicrocontrollers/service-and-support/Orange-Pi-3-LTS.html">Orange Pi - Orangepi</a>下载官方镜像，本文选择debian。</p>
</li>
<li>
<p>执行如下指令：</p>
<pre><code class="language-bash">dd if=&lt;orange_img&gt; of=/dev/sdd</code></pre>
<p>执行此命令先烧录，然后执行如下命令挂载到系统：</p>
<pre><code class="language-bash">sudo mount -o loop,offset=$((8192*512)) ~/下载/Orangepi3-lts_3.0.0_debian_bullseye_server_linux5.16.17.img /mnt/opipc_image</code></pre>
</li>
<li>
<p>执行如下命令删除sd卡的所有文件（除了引导文件外）：</p>
<pre><code class="language-bash">sudo rm -rf *</code></pre>
</li>
<li>
<p>执行如下指令拷贝rootfs：</p>
<pre><code class="language-bash">sudo wget https://bouncer.gentoo.org/fetch/root/all/releases/arm64/autobuilds/20220724T233143Z/stage3-arm64-openrc-20220724T233143Z.tar.xzhttps://bouncer.gentoo.org/fetch/root/all/releases/arm64/autobuilds/20220724T233143Z/stage3-arm64-openrc-20220724T233143Z.tar.xz
sudo wget http://gentoo.aditsu.net:8000/snapshots/portage-latest.tar.xz
sudo tar xpvf stage3-*.tar.xz --xattrs-include='*.*' --numeric-owner
sudo tar xpvf portage-latest.tar.xz --xattrs-include='*.*' --numeric-owner -C /usr</code></pre>
</li>
<li>
<p>拷贝官方的引导文件：</p>
<pre><code class="language-bash">sudo cp -r /mnt/opipc_img/boot/* boot/</code></pre>
<p>编辑<code>boot.cmd</code>文件，内容如下：</p>
<pre><code class="language-uboot">
# DO NOT EDIT THIS FILE
#
# Please edit /boot/orangepiEnv.txt to set supported parameters
#</code></pre>
</li>
</ol>
<h1>default values</h1>
<p>setenv load_addr "0x45000000"<br />
setenv overlay_error "false"<br />
setenv rootdev "/dev/mmcblk0p1"<br />
setenv verbosity "1"<br />
setenv rootfstype "ext4"<br />
setenv console "both"<br />
setenv docker_optimizations "on"<br />
setenv bootlogo "false"</p>
<h1>Print boot source</h1>
<p>itest.b <em>0x10028 == 0x00 &amp;&amp; echo "U-boot loaded from SD"<br />
itest.b </em>0x10028 == 0x02 &amp;&amp; echo "U-boot loaded from eMMC or secondary SD"<br />
itest.b *0x10028 == 0x03 &amp;&amp; echo "U-boot loaded from SPI"</p>
<p>echo "Boot script loaded from ${devtype}"</p>
<p>if test -e ${devtype} ${devnum} ${prefix}orangepiEnv.txt; then<br />
load ${devtype} ${devnum} ${load_addr} ${prefix}orangepiEnv.txt<br />
env import -t ${load_addr} ${filesize}<br />
fi</p>
<p>if test "${console}" = "display" || test "${console}" = "both"; then setenv consoleargs "console=ttyS0,115200 console=tty1"; fi<br />
if test "${console}" = "serial"; then setenv consoleargs "console=ttyS0,115200"; fi<br />
if test "${bootlogo}" = "true"; then setenv consoleargs "bootsplash.bootfile=bootsplash.orangepi ${consoleargs}"; fi</p>
<h1>get PARTUUID of first partition on SD/eMMC it was loaded from</h1>
<h1>mmc 0 is always mapped to device u-boot (2016.09+) was loaded from</h1>
<p>if test "${devtype}" = "mmc"; then part uuid mmc 0:1 partuuid; fi</p>
<p>setenv bootargs "root=${rootdev} rootwait init=/sbin/init rootfstype=${rootfstype} ${consoleargs} consoleblank=0 loglevel=${verbosity} ubootpart=${partuuid} usb-storage.quirks=${usbstoragequirks} ${extraargs} ${extraboardargs} earlycon=<br />
serial0:115200n8"</p>
<p>if test "${docker_optimizations}" = "on"; then setenv bootargs "${bootargs} cgroup_enable=memory swapaccount=1"; fi</p>
<p>load ${devtype} ${devnum} ${fdt_addr_r} ${prefix}dtb/${fdtfile}<br />
fdt addr ${fdt_addr_r}<br />
fdt resize 65536<br />
for overlay_file in ${overlays}; do<br />
if load ${devtype} ${devnum} ${load_addr} ${prefix}dtb/allwinner/overlay/${overlay_prefix}-${overlay_file}.dtbo; then<br />
echo "Applying kernel provided DT overlay ${overlay_prefix}-${overlay_file}.dtbo"<br />
fdt apply ${load_addr} || setenv overlay_error "true"<br />
fi<br />
done<br />
for overlay_file in ${user_overlays}; do<br />
if load ${devtype} ${devnum} ${load_addr} ${prefix}overlay-user/${overlay_file}.dtbo; then<br />
echo "Applying user provided DT overlay ${overlay_file}.dtbo"<br />
fdt apply ${load_addr} || setenv overlay_error "true"<br />
fi<br />
done<br />
if test "${overlay_error}" = "true"; then<br />
echo "Error applying DT overlays, restoring original DT"<br />
load ${devtype} ${devnum} ${fdt_addr_r} ${prefix}dtb/${fdtfile}<br />
else<br />
if load ${devtype} ${devnum} ${load_addr} ${prefix}dtb/allwinner/overlay/${overlay_prefix}-fixup.scr; then<br />
echo "Applying kernel provided DT fixup script (${overlay_prefix}-fixup.scr)"<br />
source ${load_addr}<br />
fi<br />
if test -e ${devtype} ${devnum} ${prefix}fixup.scr; then<br />
load ${devtype} ${devnum} ${load_addr} ${prefix}fixup.scr<br />
echo "Applying user provided fixup script (fixup.scr)"<br />
source ${load_addr}<br />
fi<br />
fi</p>
<p>load ${devtype} ${devnum} ${ramdisk_addr_r} ${prefix}uInitrd<br />
load ${devtype} ${devnum} ${kernel_addr_r} ${prefix}Image</p>
<p>booti ${kernel_addr_r} ${ramdisk_addr_r} ${fdt_addr_r}</p>
<h1>Recompile with:</h1>
<h1>mkimage -C none -A arm -T script -d /boot/boot.cmd /boot/boot.scr</h1>
<pre><code>
并执行如下命令：

```bash
sudo mkimage -C none -A arm64 -T script -d boot.cmd boot.scr</code></pre>
<h2>执行初始化设置</h2>
<p>执行以下命令：</p>
<pre><code class="language-bash">ip addr add 192.168.3.200/24 dev eth0
ip link set eth0 up
ip route add 0.0.0.0/0 via 192.168.3.1
data -s '&lt;data&gt;' # 设置日期
data -s '&lt;time&gt;' # 设置时间
emerge-webrsync
emerge --sync
emerge @world --ask</code></pre>
<p>此后还需要编辑<code>inittab</code> 以便开启串口控制台的初始化程序。</p>
<h2>编译Gentoo Linux主线内核</h2>
<p>现在我们还只是使用官方的引导内核，现在我们将构建自己的内核，执行如下指令：</p>
<pre><code class="language-bash">emerge --ask gentoo-sources
emerge --ask dracut
eselect kernel set 1
cd /usr/src/linux
cp /boot/config .config
make menuconfig
make
make modules_install
mv /boot /boot.old
mkdir /boot.new
# 根据需要利用软链接切换，拷贝必要的引导文件（除了内核部分）
dracut --kver=5.15.52-gentoo</code></pre>
<h2>构建uInitrd</h2>
<p>从物理机执行如下命令：</p>
<pre><code class="language-bash">sudo mkimage -C none -A arm64 -T ramdisk -n uInitrd -d &lt;img&gt; uInitrd</code></pre>
<p>当你建立好正确的软链接关系后，重新启动，系统正常引导说明成功</p>
<h2>系统设置完成</h2>";s:12:"content_meta";N;}